# LiveKit 部署常见问题解答

## 问题 1: 单机版本是否需要配置 Redis？

### 答案：**需要**

即使是单机部署，也需要 Redis。原因如下：

#### 为什么单机也需要 Redis？

1. **会话管理** - Redis 存储用户会话信息
2. **房间状态** - Redis 存储房间的实时状态
3. **消息队列** - Redis 用于服务间通信
4. **缓存** - Redis 缓存热点数据

#### 单机 Redis 配置

```bash
# .env 配置
REDIS_HOST=redis
REDIS_PORT=6379
REDIS_PASSWORD=          # 单机可以不设置密码
REDIS_DB=0
REDIS_MAXMEMORY=2gb
REDIS_MAXMEMORY_POLICY=allkeys-lru
```

#### 单机 Docker Compose 中的 Redis

```yaml
redis:
  image: redis:7-alpine
  container_name: livekit-redis
  ports:
    - "6379:6379"
  volumes:
    - ./config/redis.conf:/usr/local/etc/redis/redis.conf:ro
    - ./volumes/redis:/data
  command: redis-server /usr/local/etc/redis/redis.conf
  networks:
    - livekit
  restart: unless-stopped
```

---

## 问题 2: 脚本是否支持从单机升级到分布式？

### 答案：**支持**

升级流程非常简单：

### 升级步骤

```bash
# 第 1 步：备份当前数据
./deploy.sh backup

# 第 2 步：修改 .env 文件
# 从：NODES=localhost
# 改为：NODES=192.168.1.10,192.168.1.11,192.168.1.12

nano .env

# 第 3 步：重新部署（自动检测为分布式）
./deploy.sh deploy

# 第 4 步：验证部署
./deploy.sh verify
```

### 升级过程中发生了什么？

1. ✅ 旧的单机容器被停止
2. ✅ Redis 数据被保留
3. ✅ 新的分布式配置被生成
4. ✅ 3 个 LiveKit 节点被启动
5. ✅ 所有数据自动迁移

### 数据保留

- ✅ Redis 数据完全保留
- ✅ 配置文件保留
- ✅ 现有房间信息保留
- ✅ 用户会话保留

---

## 问题 3: 分布式部署是否需要在三台机器上都执行脚本？

### 答案：**是的，需要在每台机器上都执行**

### 分布式部署架构

```
┌─────────────────────────────────────────────────────────┐
│                    Caddy 反向代理                        │
│              (负载均衡 + HTTPS 证书)                    │
│                  livekit.example.com                    │
└────────────┬────────────────────────────────┬───────────┘
             │                                │
    ┌────────▼────────┐          ┌────────────▼────────┐
    │  机器 1 (Node1) │          │  机器 2 (Node2)     │
    │  IP: 192.168... │          │  IP: 192.168...     │
    │                 │          │                     │
    │ ┌─────────────┐ │          │ ┌─────────────┐     │
    │ │ LiveKit     │ │          │ │ LiveKit     │     │
    │ │ Server      │ │          │ │ Server      │     │
    │ │ Port: 7880  │ │          │ │ Port: 7880  │     │
    │ └─────────────┘ │          │ └─────────────┘     │
    │                 │          │                     │
    │ ┌─────────────┐ │          │ ┌─────────────┐     │
    │ │ Redis       │ │          │ │ Redis       │     │
    │ │ (本地缓存)  │ │          │ │ (本地缓存)  │     │
    │ └─────────────┘ │          │ └─────────────┘     │
    └────────┬────────┘          └────────┬────────────┘
             │                            │
             └────────────┬───────────────┘
                          │
                  ┌───────▼────────┐
                  │  Redis 主节点  │
                  │  (共享存储)    │
                  │  IP: 192.168...│
                  │  Port: 6379    │
                  └────────────────┘
```

### 部署步骤

#### 第 1 步：在所有机器上准备

```bash
# 在机器 1、2、3 上都执行
chmod +x *.sh
cp .env.example .env
```

#### 第 2 步：配置 Redis 主节点

首先，在一台机器上部署 Redis 主节点（例如机器 3）：

```bash
# 在机器 3 上执行
# .env 配置
REDIS_HOST=192.168.1.12        # 机器 3 的 IP
REDIS_PORT=6379
REDIS_PASSWORD=your_password   # 设置密码
```

#### 第 3 步：在所有机器上配置相同的 NODES

```bash
# 在机器 1、2、3 上都执行
# .env 配置
NODES=192.168.1.10,192.168.1.11,192.168.1.12
REDIS_HOST=192.168.1.12        # 指向 Redis 主节点
REDIS_PASSWORD=your_password
```

#### 第 4 步：在所有机器上部署

```bash
# 在机器 1、2、3 上都执行
./deploy.sh deploy
```

#### 第 5 步：验证部署

```bash
# 在任意机器上执行
./deploy.sh verify
```

### 关键点

| 项目 | 说明 |
|------|------|
| **NODES** | 所有机器上配置相同 |
| **Redis** | 只在一台机器上部署主节点 |
| **Caddy** | 每台机器都有自己的 Caddy（可选） |
| **LiveKit** | 每台机器都有自己的 LiveKit 节点 |

---

## 问题 4: 分布式部署中 Redis 需要配置什么？

### 答案：Redis 需要特殊配置以支持分布式

### Redis 配置要点

#### 1. 密码保护（必需）

```bash
# .env 配置
REDIS_PASSWORD=your_secure_password
```

#### 2. 持久化配置

```bash
# redis.conf
appendonly yes                 # 启用 AOF 持久化
appendfsync everysec          # 每秒同步一次
```

#### 3. 内存配置

```bash
# redis.conf
maxmemory 2gb                 # 最大内存
maxmemory-policy allkeys-lru  # 内存淘汰策略
```

#### 4. 网络配置

```bash
# redis.conf
bind 0.0.0.0                  # 监听所有网卡
port 6379                     # 监听端口
```

### 完整的 Redis 配置示例

```yaml
# docker-compose.yml 中的 Redis 配置
redis:
  image: redis:7-alpine
  container_name: livekit-redis
  ports:
    - "6379:6379"
  volumes:
    - ./config/redis.conf:/usr/local/etc/redis/redis.conf:ro
    - ./volumes/redis:/data
  command: redis-server /usr/local/etc/redis/redis.conf --requirepass your_password
  networks:
    - livekit
  restart: unless-stopped
  healthcheck:
    test: ["CMD", "redis-cli", "-a", "your_password", "ping"]
    interval: 10s
    timeout: 5s
    retries: 5
```

### Redis 主从配置（高可用）

如果需要 Redis 高可用，可以配置主从：

```bash
# 机器 3（主节点）
REDIS_HOST=192.168.1.12
REDIS_PORT=6379
REDIS_PASSWORD=your_password

# 机器 4（从节点）
REDIS_SLAVE_OF=192.168.1.12 6379
REDIS_PASSWORD=your_password
```

---

## 问题 5: 分布式部署中，创建房间接口应该返回哪台机器的地址？

### 答案：**返回 Caddy 反向代理的地址，而不是具体的某台机器**

### 架构说明

```
┌──────────────────────────────────────────────────┐
│         前端应用                                  │
│  (Web Browser / Mobile App)                      │
└────────────────┬─────────────────────────────────┘
                 │
                 │ 所有请求都通过 Caddy
                 │
    ┌────────────▼──────────────┐
    │   Caddy 反向代理           │
    │   livekit.example.com      │
    │   (负载均衡)               │
    └────────────┬──────────────┘
                 │
        ┌────────┼────────┐
        │        │        │
    ┌───▼──┐ ┌──▼───┐ ┌──▼───┐
    │Node1 │ │Node2 │ │Node3 │
    │:7880 │ │:7880 │ │:7880 │
    └──────┘ └──────┘ └──────┘
```

### 创建房间接口实现

#### 后端代码示例（Go）

```go
package main

import (
    "github.com/gin-gonic/gin"
    "github.com/livekit/protocol/auth"
    "github.com/livekit/protocol/livekit"
)

// CreateRoomRequest 创建房间请求
type CreateRoomRequest struct {
    RoomName string `json:"room_name" binding:"required"`
    UserName string `json:"user_name" binding:"required"`
}

// CreateRoomResponse 创建房间响应
type CreateRoomResponse struct {
    RoomName    string `json:"room_name"`
    Token       string `json:"token"`
    URL         string `json:"url"`           // 返回 Caddy 地址
    ServerURL   string `json:"server_url"`    // LiveKit 服务器地址
}

// CreateRoom 创建房间
func CreateRoom(c *gin.Context) {
    var req CreateRoomRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(400, gin.H{"error": err.Error()})
        return
    }

    // 1. 生成 Token
    token, err := generateToken(req.RoomName, req.UserName)
    if err != nil {
        c.JSON(500, gin.H{"error": "Failed to generate token"})
        return
    }

    // 2. 返回 Caddy 地址（不是具体的某台机器）
    response := CreateRoomResponse{
        RoomName:  req.RoomName,
        Token:     token,
        URL:       "https://livekit.example.com",  // ✅ 返回 Caddy 地址
        ServerURL: "https://livekit.example.com",  // ✅ 返回 Caddy 地址
    }

    c.JSON(200, response)
}

// generateToken 生成 LiveKit Token
func generateToken(roomName, userName string) (string, error) {
    at := auth.NewAccessToken("your_api_key", "your_api_secret")
    grant := &auth.VideoGrant{
        RoomJoin: true,
        Room:     roomName,
    }
    at.AddGrant(grant)
    return at.ToJwt()
}
```

#### 前端代码示例（JavaScript）

```javascript
// 创建房间
async function createRoom(roomName, userName) {
    const response = await fetch('/api/create-room', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            room_name: roomName,
            user_name: userName,
        }),
    });

    const data = await response.json();
    
    // 使用返回的 URL 和 Token 连接
    const { url, token } = data;
    
    // 连接到 LiveKit
    const room = await connect(url, token, {
        audio: true,
        video: { resolution: { width: 640, height: 480 } },
    });
    
    return room;
}

// 连接到 LiveKit
async function connect(url, token, options) {
    const room = new Room();
    await room.connect(url, token, options);
    return room;
}
```

### 关键点

| 项目 | 说明 |
|------|------|
| **返回地址** | `https://livekit.example.com`（Caddy 地址） |
| **不返回** | 具体的某台机器 IP（如 192.168.1.10） |
| **原因** | Caddy 负责负载均衡和故障转移 |
| **Token** | 由后端生成，包含房间名和用户信息 |

### 为什么不返回具体的机器地址？

1. **负载均衡** - Caddy 会自动分配到最优的节点
2. **故障转移** - 如果一个节点故障，Caddy 会自动转移到其他节点
3. **透明性** - 前端无需关心后端有多少个节点
4. **可扩展性** - 添加新节点时，前端代码无需修改

### 完整的部署配置示例

#### 机器 1、2、3 的 .env 配置

```bash
# 所有机器上都相同
DOMAIN=livekit.example.com
NODES=192.168.1.10,192.168.1.11,192.168.1.12

# Redis 指向主节点（机器 3）
REDIS_HOST=192.168.1.12
REDIS_PORT=6379
REDIS_PASSWORD=your_secure_password

# API 密钥（所有机器相同）
LIVEKIT_API_KEY=your_api_key
LIVEKIT_API_SECRET=your_api_secret
```

#### Caddy 配置

```
livekit.example.com {
    reverse_proxy localhost:7880 {
        header_up X-Forwarded-For {http.request.remote}
        header_up X-Forwarded-Proto {http.request.proto}
    }
}
```

---

## 总结

| 问题 | 答案 |
|------|------|
| **1. 单机需要 Redis？** | ✅ 需要 |
| **2. 支持升级到分布式？** | ✅ 支持 |
| **3. 三台机器都要执行脚本？** | ✅ 是的 |
| **4. Redis 如何配置？** | 密码、持久化、网络配置 |
| **5. 返回哪台机器地址？** | 返回 Caddy 地址，不是具体机器 |

---

## 快速参考

### 单机部署
```bash
NODES=localhost
REDIS_HOST=redis
```

### 分布式部署
```bash
NODES=192.168.1.10,192.168.1.11,192.168.1.12
REDIS_HOST=192.168.1.12
REDIS_PASSWORD=your_password
```

### 创建房间接口返回
```json
{
    "room_name": "my-room",
    "token": "eyJhbGc...",
    "url": "https://livekit.example.com",
    "server_url": "https://livekit.example.com"
}
```

